<html>

<head>
<title>DoPC-Curso de Java.Seccion 3.2</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">

<meta name="Microsoft Border" content="b"></head>

<body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><!--msnavigation--><td valign="top">

<h3>Sección 3.2: Métodos <em>static</em> y variables <em>static</em></h3>

<hr>

<p>EN JAVA, TODAS LAS SUBRUTINAS SE DEBEN DEFINIR dentro de una clase. Esto hace a Java
tan especial en medio de los lenguajes de programación, ya que hay algunos que permiten
que las subrutinas existan libremente. Uno de los propósitos de la clase, es poder
agrupar juntos las subrutinas relacionadas y las variables. Quizás los diseñadores de
Java pensaron que todo debía estar relacionado con algo. Con esta filosófica
motivación, los diseñadores de Java quisieron establecer un fuerte control acerca de
cómo se podían llamar las cosas, dado que un programa Java, potencialmente tenia acceso
a un numero enorme de subrutinas esparcidas por toda Internet. El hecho de agrupar estas
subrutinas en clases ( y como veremos mas adelante, las clases se agrupan en algo llamado
&quot;packages&quot;) ayuda a controlar la confusión resultante por tanto nombre
distinto.</p>

<p>La subrutina que es miembro de una clase, normalmente se le llama <font color="#808000">método</font>
, y &quot;método&quot;, es el termino preferido en Java para las subrutinas. Voy a
empezar a utilizar el termino &quot;método&quot;, sin embargo, también continuare
utilizando el termino subrutina porque es mas general, y se puede aplicar a todos los
lenguajes de programación.</p>

<p>En Java un método puede ser <font color="#808000">static</font> o <font color="#808000">non-static</font>. Un método <em>non-static</em> se emplea en la
programación orientada a objetos que veremos en el siguiente <a href="indice4.htm" tppabs="http://members.nbci.com/elcurso/Capitulo4/indice4.htm">capítulo</a>. Por el resto del capítulo, hablaremos
únicamente de los métodos <em>static</em>. Un método <em>static</em> es una subrutina
ordinaria que tiene la misma funcionalidad en Java que en cualquier otro lenguaje de
programación no orientado a objetos.</p>

<hr width="50%">

<p>La definición de un método en Java tiene la siguiente forma:</p>

<pre>      <font color="#009000"><b>modificadores tipo-retorno nombre-</b></font>método ( <font color="#009000"><b>lista-</b></font>parámetros ) {
          <font color="#009000"><b>instrucciones</b></font>
      }</pre>

<p>Las <font color="#009000"><b>instrucciones</b></font> deben escribirse entre llaves, {
y }, están dentro de la &quot;caja negra&quot;, que hemos explicado en la <a href="Seccion3_1.html" tppabs="http://members.nbci.com/elcurso/Capitulo3/Seccion3_1.html">sección anterior</a>. Son las instrucciones que el ordenador
ejecuta cuando se llama al método. La subrutinas pueden contener cualquiera de las
instrucciones presentadas en el <a href="indice2.htm" tppabs="http://members.nbci.com/elcurso/Capitulo2/indice2.htm">Capítulo 2</a>. Ya
hemos visto bastantes ejemplos de métodos, llamados <tt>subroutines main()</tt>en los
programas ejemplo que hemos visto hasta ahora. Aquí tenemos algunos ejemplos con la parte
&quot;interna&quot; omitida (pero recuerde que semejantes definiciones, solo pueden
aparecer dentro de las clases):</p>

<p>&nbsp;</p>

<pre>       static void playGame() {
           // &quot;static&quot; es el modificador; &quot;void&quot; es tipo-retorno;
           // &quot;playGame&quot; es el nombre; la lista de parámetros
           // esta vacía
           . . .  // las instrucciones para definir el método van aquí
       }
       
       int getNextN(int N) {
           // no hay modificadores; &quot;int&quot; es el tipo retorno
           // &quot;getnextN&quot; es el nombre del método;
	   // la lista de parámetros incluye uno
           // llamado &quot;N&quot; y con tipo &quot;int&quot;
           . . .  // instrucciones para definir el método
       }
       
       public static boolean lessThan(double x, double y) {
           // &quot;public&quot; y &quot;static&quot; son modificadores;
	   // &quot;boolean&quot; es el tipo a retornar;
           // &quot;lessThan&quot; es el nombre del método;
	   // la lista de parámetros incluye dos con
           // nombres &quot;x&quot; e &quot;y&quot;, el tipo de cada parámetro
           // es &quot;double&quot;
           . . .  // instrucciones para implementar el método
       }</pre>

<p>Los <font color="#009000"><b>modificadores </b></font>son palabras que definen ciertas
características del método, como si es <em>static</em> o no. En el segundo ejemplo que
presentamos, <tt>getNextN</tt> es un método <em>non-static</em> dado que en su
definición no incluye el modificador &quot;<tt>static</tt>&quot; -- y esto no es un
ejemplo de lo que vamos a ver en este capítulo!. El otro modificador que presentamos en
este ejemplo, es &quot;<tt>public</tt>&quot;. Este modificador indica que el método puede
ser llamado desde cualquier lugar del programa e incluso desde fuera de la clase en donde
se ha definido. Otro modificado &quot;<tt>private</tt>&quot; indica que el método puede
ser llamado <strong>únicamente</strong> desde dentro de la clase. Los modificadores <tt>public</tt>
y <tt>private</tt> se llaman <font color="#808000">limitadores de acceso</font> (<font color="#808000">access specifiers</font>). ( Si en un método no se definen limitadores de
acceso, por defecto este método puede ser llamado por cualquiera dentro del
&quot;package&quot; que contiene a la clase --Veremos mas sobre &quot;packages&quot; en la
<a href="seccion3_5.html" tppabs="http://members.nbci.com/elcurso/Capitulo3/seccion3_5.html">Sección 5</a>.) Hay algunos otros modificadores que iremos
viendo a lo largo del curso.</p>

<p>(De alguna manera, puede sentirse extrañado de que existan los limitadores de acceso.
Porqué no se permite que todo sea público?. Bien, piense que la misma clase, es una
especie de caja negra. Los métodos públicos son parte de la interface de la caja negra,
mientras que los métodos privados son parte de la implementacion oculta de la caja. Las
reglas de las cajas negras implican que solo se debe declarar un método como publico si
es realmente una parte importante de la interface que se ve desde fuera de la caja. Quiere
verlo realmente?.)</p>

<p>Algunas subrutinas están diseñadas para calcular y devolver valores. Estas
subrutinas, se llaman <font color="#808000">funciones</font>. Hemos visto ejemplos de
funciones matemáticas como <tt>Math.sqrt(x)</tt> y <tt>Math.random()</tt> en la <a href="Seccion2_6.html" tppabs="http://members.nbci.com/elcurso/Capitulo2/Seccion2_6.html">Sección 2.6</a>. Si escribe un método que va a ser
usado como función, deberá especificar el&nbsp; <font color="#009000"><b>tipo de retorno</b></font>
del método que será el tipo de valor que se calcula con la función. Por ejemplo el <font color="#009000"><b>tipo de retorno</b></font> boleano en</p>

<p align="center"><tt>public static boolean lessThan(double x, double y)</tt></p>

<p align="left">indica que la función <tt>lessThan</tt> calcula un valor boleano.
Estudiaremos mas las funciones en la <a href="Seccion3_4.html" tppabs="http://members.nbci.com/elcurso/Capitulo3/Seccion3_4.html">Sección 4</a></p>

<p align="left">Un método también puede ser usado como una subrutina normal, para
indicarle que no devuelve ningún valor, deberemos especificar como tipo de retorno &quot;<tt>void</tt>&quot;.
Este termino se emplea para indicar que no existe valor de retorno o que este esta vacío.</p>

<p align="left">Finalmente viene la <font color="#009000"><b>lista de parámetros </b></font>del
método. Los parámetros forman parte de la interface de la subrutina. Representan la
información que se pasa a la subrutina desde el exterior, para que sea usada por la
subrutina en sus cálculos internos. Para un ejemplo concreto, imaginemos una clase
llamada <tt>Televisión</tt> que incluye el método llamado <tt>changeChanel()</tt>. La
pregunta inmediata es : A que canal queremos cambiar?.El parámetro se puede utilizar para
resolver esta cuestión. Dado que el numero de canal es un entero, el tipo del parámetro
debería ser <tt>int</tt> y la declaración del método <tt>changeChanel()</tt> podría
ser así:&nbsp; </p>

<p align="center"><tt>public void changeChannel(int channelNum) {...}</tt></p>

<p align="left">Esta declaración indica que<tt> changeChanel()</tt>tiene un parámetro de
tipo <tt>int</tt>. Cuando se llama&nbsp; a la subrutina se le debe proporcionar un numero
de canal; por ejemplo <tt>changeChanel(127);</tt></p>

<p align="left">Los parámetros los trataremos en detalle en la <a href="Seccion3_3.html" tppabs="http://members.nbci.com/elcurso/Capitulo3/Seccion3_3.html">siguiente
</a>sección.</p>

<hr width="50%">

<p>Cuando define una subrutina, deberá decirle al ordenador que la subrutina existe, y
que la quiere utilizar. La subrutinas no se ejecutan hasta que son llamadas. (Esto es
cierto excepto para el método MAIN()--aun cuando no se le llame, cuando el sistema
arranca el programa, lo llama directamente). Por ejemplo el método <tt>playGame()</tt>
definido anteriormente, puede ser llamado utilizando la siguiente instrucción de llamada
a subrutina:</p>

<p align="center"><tt>playGame()</tt></p>

<p align="left">Esta instrucción puede aparecer en cualquier sitio de la misma clase que
incluye la definición de<tt> playGame()</tt>, desde el método <tt>main()</tt> o desde
cualquier otro método. Dado que <tt>playGame()</tt> en un método público, también
puede ser llamado desde otras clases, pero en ese caso, le deberá indicar al ordenador
que clase lo contiene. Supongamos por ejemplo que <tt>playGame()</tt> esta definido en una
clase llamada<tt> Poker</tt>. Entonces para efectuar la llamada desde fuera de la clase,
debería escribir:</p>

<p align="center"><tt>Poker.playGame();</tt></p>

<p align="left">Para usar el nombre de clase, aquí debe decirle al ordenador en que clase
debe buscar para encontrar el método. Eso también le permite distinguir entre <tt>Poker.playGame()</tt>
y otro posible método <tt>playGame()</tt> definido en otra clase como <tt>Roulette.playGame()
o Blackjack.playGame().</tt></p>

<p align="left"><font face="m">De forma general, la instrucción de llamada a una
subrutina tiene la forma:</font></p>

<p align="center"><tt><font color="#009000"><b>nombre-</b></font>método(<font color="#009000"><b>parámetros</b></font>);</tt></p>

<p>si el método esta definido en la misma clase o</p>

<p align="center"><tt><font color="#009000"><b>nombre-clase</b></font>.<font color="#009000"><b>nombre-</b></font>método(<font color="#009000"><b>parámetros</b></font>);</tt></p>

<p>si el método es <em>static</em>&nbsp; definido en cualquier parte , en diferente
clase, (Los <em>Non-static</em> definido en otras clases tienen un comportamiento
ligeramente distinto, como veremos mas adelante)</p>

<hr width="50%">

<p>Es el momento de presentar como ejemplo un programa completo para que pueda ver como
incluye otros métodos además del método <tt>main</tt>. Aquí esta el programa para
poder jugar con el usuario a adivinar números -- excepto que he omitido el interior del
método<tt> playGame()</tt></p>

<pre>         public class GuessingGame {
         
            public static void main(String[] args) {
               Console console = new Console();
               
               console.putln(&quot;Quiero jugar.  Pensaré un número entre&quot;);
               console.putln(&quot;1 y 100, y pruebe a ver si lo adivina.&quot;);
               
               boolean playAgain;
               
               do {
                  playGame();  // llama a la subrutina para jugar
                  console.put(&quot;Quiere jugar otra vez? &quot;);
                  playAgain = console.getlnBoolean();
               } while (playAgain);

               console.close();
            } // end of main()
            
            
            static void playGame() {
               . . .  // instrucciones de implementacion del juego
            } // end of playGame()
            
         } // end of class GuessingGame
         </pre>

<p>Esto es el boceto del posible programa para jugar, pero tan pronto como acabé la
definición de <tt>playGame</tt>, me encontré con un problema!. El problema es que
necesito hacerle preguntas al usuario y leer sus respuestas, y por lo tanto, necesito usar
la consola. Sin embargo la <font face="o"><tt>console</tt> es una variable local definida
dentro de la subrutina <tt>main()</tt>. Las reglas dicen que una variable definida
localmente, dentro de la subrutina, es parte de la caja negra, y es completamente
inaccesible desde fuera. Así no hay forma de que pueda usar la consola desde dentro de <tt>playGame()</tt>!
( En caso de que se extrañe, si estoy definiendo en <tt>playGame()</tt></font><font face="m"> una variable <tt>Console</tt> será completamente distinta a la <tt>console</tt>
definida en <tt>main()</tt> -- y serán don ventanas distintas en la pantalla!).</font></p>

<p><font face="m">Hay una solución sencilla: En lugar de inicializar en la subrutina una
variable local, <tt>console</tt>&nbsp; puede ser una variable&nbsp; <em>static</em>
perteneciente a la clase <tt>GuessingGame.</tt>La variable puede ser declarada en la clase
fuera de cualquier subrutina.Esas variables pueden ser indistintamente <em>static</em> o <em>non-static</em>,
pero&nbsp; este método, lo utilizaremos en este capítulo para las <em>static</em>. Los
miembros variables, pueden ser declarados indistintamente <tt>public</tt> o <tt>private</tt>.
Un miembro variable <em>static</em> puede ser utilizado en cualquier subrutina definida en
la misma clase. Y si es publico puede ser accedido desde fuera de la clase utilizando el
nombre compuesto con la forma:</font></p>

<p align="center"><tt><font color="#009000"><b>class-name</b></font>.<font color="#009000"><b>variable-name</b></font></tt></p>

<p>Mientras que en una subrutina, una variable local solo existe mientras la subrutina se
ejecuta, una variable <em>static</em> existe mientras el programa este funcionando. Por
mover la declaración de <tt>console</tt> fuera de la subrutina <tt>main()</tt> la
transformamos en variable <em>static</em> y que puede ser accedida por cualquiera de las
dos rutinas, <tt>main(),</tt> y <tt>playGame()</tt>. Aquí esta el programa ejemplo
completo:</p>

<pre>         public class GuessingGame {
         
            static Console console;  // declara console como static variable
         
            public static void main(String[] args) {
               console = new Console(); 
                              
               console.putln(&quot;Quiero jugar.  Pensare un número entre&quot;);
               console.putln(&quot;1 y 100, y pruebe a ver si lo adivina.&quot;);
               
               boolean playAgain;
               
               do {
                  playGame();  // call subroutine to play one game
                  console.put(&quot;Quiere jugar otra vez? &quot;);
                  playAgain = console.getlnBoolean();
               } while (playAgain);

               console.close();
            } // end of main()
            
            
            static void playGame() {
                void playGame() {
        	int computersNumber = (int)(100 * Math.random()) + 1;
              // El valor asignado a computerNumber es aleatorio
              // y escogido entre 1 y 100, inclusive
       		int usersGuess; // aquí se guarda el numero pensado por el usuario
        	console.putln();
        	console.put(&quot;Cual es su primera jugada? &quot;);
        	do {
            	usersGuess = console.getInt();
            	if (usersGuess == computersNumber)
                 console.putln(&quot;Lo consiguió!  Mi numero era &quot; + computersNumber);
            	else if (usersGuess &lt; computersNumber)
                  console.put(&quot;Es muy bajo, vuelva a probar: &quot;);
            	else if (usersGuess &gt; computersNumber)
                  console.put(&quot;Es muy alto, vuelva a probar: &quot;);
         	} while (usersGuess != computersNumber);
         	console.putln();
      	    } // end of playGame()
            
         } // end of class GuessingGame
         </pre>

<p>Tómese algo de tiempo para leer el programa cuidadosamente e intente adivinar como
funciona. Y pruebe de convencerse usted mismo utilizando un caso relativamente simple,
separe el programa en dos subrutinas para que le sea mas fácil entenderlo y probablemente
lograra que le sea fácil el escribir cada parte.</p>

<p>Puede probar la salida con el programa de simulación aquí:</p>

<p align="center">
<applet code="GuessingGameConsole.class" tppabs="http://members.nbci.com/elcurso/Capitulo3/GuessingGameConsole.class" height="300" width="420">

<p align="center"><font color="#E70000">Lo siento peso su navegador<br>
no soporta Java.</font></applet>
</p>

<table border="0" width="100%" height="62" style="border-top: medium ridge">
  <tr>
    <td width="33%" height="58"><a href="Seccion3_1.html" tppabs="http://members.nbci.com/elcurso/Capitulo3/Seccion3_1.html"><img src="atras.gif" tppabs="http://members.nbci.com/elcurso/images/atras.gif" alt="Anterior" border="0" align="right" style="margin-top: 0px; margin-bottom: 0px" WIDTH="62" HEIGHT="62"></a></td>
    <td width="33%" height="58"><p align="center">&nbsp;&nbsp;&nbsp;&nbsp; <a href="indice3.htm" tppabs="http://members.nbci.com/elcurso/Capitulo3/indice3.htm"><img src="bicap.jpg" tppabs="http://members.nbci.com/elcurso/images/bicap.jpg" width="67" height="69" alt="Indice del Capitulo" border="0"></a><a href="indice.htm" tppabs="http://members.nbci.com/elcurso/indice.htm"><img src="bigen.jpg" tppabs="http://members.nbci.com/elcurso/images/bigen.jpg" width="66" height="68" alt="Indice General" border="0"></a></td>
    <td width="34%" height="58"><a href="Seccion3_3.html" tppabs="http://members.nbci.com/elcurso/Capitulo3/Seccion3_3.html"><img src="siguiente.gif" tppabs="http://members.nbci.com/elcurso/images/siguiente.gif" alt="Siguiente" align="left" border="0" WIDTH="63" HEIGHT="63"></a></td>
  </tr>
</table>
&nbsp;<!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td>

</td></tr><!--msnavigation--></table></body>
</html>
