<html>

<head>
<title>DoPC-Curso de Java.Seccion 6.2</title>
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">

<meta name="Microsoft Border" content="b"></head>

<body><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><!--msnavigation--><td valign="top">

<h3>Sección 6.2: La clase Components</h3>

<hr>

<p>EN ESTA SECCIÖN, voy a comentar varias subclases de la clase Components. Quiero
mostrarles como se pueden crear componentes pertenecientes a esa clase y explicar algunos
de sus métodos. Los eventos que pueden generar esos componentes se comentan en la <a href="seccion6_3.htm" tppabs="http://members.nbci.com/elcurso/Capitulo6/seccion6_3.htm">Sección 3</a>. También daré un ejemplo de un applet que emplea
algunos componentes de esa clase. Los componentes presentados en esta sección, no son
contenedores, esto es, no pueden contener otros componentes. Las clases de contenedores se
presentaron en la <a href="seccion6_1.htm" tppabs="http://members.nbci.com/elcurso/Capitulo6/seccion6_1.htm">Sección 1</a>.Tenga en cuenta que para emplear
alguno de los componentes comentados en esta sección,debe añadirlo a un contenedor, ya
sea applet o panel, usando alguno de sus métodos <tt>add()</tt>.</p>

<hr width="50%">

<h3>La clase Canvas</h3>

<p>Un objeto de tipo Canvas es únicamente un objeto de forma rectangular en su pantalla.
Un objeto que pertenezca directamente a la clase Canvas,--al contrario que un objeto que
pertenezca a alguna de sus subclases-- no es muy útil. El motivo es que Canvas recibe los
eventos de teclado y ratón, pero no hace nada con ellos. Tienen un método <tt>paint()</tt>,
pero no dibuja nada. Es por esto que la clase Canvas generalmente es usada como base para
las subclases, y los objetos útiles se crean desde las subclases. Una subclase de Canvas
deberá sobregrabar el método <tt>paint()</tt> y puede que también los métodos de
control de eventos de ratón y teclado como <tt>mouseDown()</tt> y <tt>keyDown()</tt></p>

<p>Igual que pasa con el resto de componentes, el sistema llamara al método <tt>paint()</tt>
del área <em>canvas</em>, cuando dicha área necesite volver a ser dibujada. Cuando el
contenido del área deba ser modificado fuera del método <tt>paint(),</tt> el contexto
gráfico para el área debe ser obtenido llamando al método<tt> getGraphics().</tt>Todos
los métodos gráficos comentados en la <a href="seccion5_4.htm" tppabs="http://members.nbci.com/elcurso/Capitulo5/seccion5_4.htm">Sección 5.4</a>
pueden ser usados en este área.</p>

<p>Es posible dibujar en cualquier componente, y es muy común el dibujar directamente en
los applets y en las ventanas. Probablemente deberemos considerar como buen estilo, sin
embargo, el restringir todos los dibujos a las subclases de <tt>Canvas</tt>. Cuando solo
una parte del applet o de la ventana se utiliza para dibujar, el empleo de un área <em>canvas</em>
se hace casi inevitable. El problema se complica si quiere dibujar , por ejemplo, en una
zona donde debajo haya una fila de botones. El área <em>canvas</em> en este caso puede
ser el componente del centro de <tt>BorderLayout</tt> que se comento en la sección
anterior.</p>

<p>Canvas es la única clase comentada en esta sección para la que deberá definir
subclases. Para el resto de clases podrá crear directamente un objeto de la clase, y
emplearlo.</p>

<hr width="50%">

<h3>La clase Label</h3>

<p><tt>Labels</tt> es realmente el tipo de componente mas sencillo. Un objeto de este
tipo, es únicamente una única línea de texto. Este texto, no puede ser editado por el
usuario, aunque sí puede ser cambiado por su programa. El constructor para <tt>Label</tt>
especifica el texto a presentar:</p>
<div align="center"><center>

<pre>Label mensaje = new Label(&quot;Hola Mundo!&quot;);  </pre>
</center></div>

<p align="left">Puede cambiar el texto presentado en la etiqueta (label) llamando al
método de <tt>label setText()</tt>:</p>
<div align="center"><center>

<pre>mensaje.setText(&quot;Adiós Mundo!&quot;);  </pre>
</center></div>

<p>Dado que la clase&nbsp; <tt>Label</tt> es una&nbsp; subclase de <tt>Component</tt>,<tt>Labels</tt>
hereda un montón de comportamientos desde <tt>Components</tt>. En particular , las
etiquetas tienen color de fondo (background), color de primer plano o de texto
(foreground) y fuentes. Puede estableces estas propiedades llamando a los métodos
definidos en la clase <tt>Component</tt>. Generalmente, lo deberá realizar justo después
de haber creado la etiqueta (label).</p>

<blockquote>
  <blockquote>
    <blockquote>
      <pre>Label mensaje = New Label(&quot;Hola Mundo!&quot;);
mensaje.setForeground(Color.red);  // presentara texto en rojo
mensaje.setBackground(Color.black); // en fondo negro
mensaje.setFont(new Font(&quot;TimesRoman&quot;, Font.BOLD, 18));</pre>
      <hr width="50%">
    </blockquote>
  </blockquote>
</blockquote>

<h3>La clase Button</h3>

<p>Un objeto de la clase <tt>Button</tt> en clásico botón pulsador. El usuario puede
pulsar el botón por medio del ratón. La etiqueta del botón se indica en el momento en
que se crea:</p>
<div align="center"><center>

<pre>Button BotonParaMarcha = new Button(&quot;Arrancar&quot;);  </pre>
</center></div>

<p align="left">La etiqueta del botón se puede cambiar usando el método <tt>setLabel():</tt></p>
<div align="center"><center>

<pre>BotonParaMarcha.setLabel(&quot;Parar&quot;)  </pre>
</center></div>

<p>Cuando el usuario pulsa el botón, su programa debe responder realizando alguna
acción. El mismo botón responde generando un evento. Su programa debe detectar el evento
y reaccionar ante él; todo esto se comentara en la siguiente sección.</p>

<p>También puede ser que a veces nos interese que el botón este <font color="#808000">desactivado
(disabled)</font> porque la acción que representa no es correcta en ese momento o no
tiene sentido hacerla. En este caso es posible llamar al método del botón <tt>disable()</tt>.
Este método bloquea las respuestas&nbsp; a eventos del botón y cambia su apariencia para
indicarle al usuario que esta desactivado. Para volver a activar el botón, deberá llamar
al método <tt>enable()</tt>. Estos métodos están definidos realmente en la clase <tt>Component</tt>
y se pueden utilizar además de para los botones, también para otros tipos de
componentes.</p>

<hr width="50%">

<h3>Las clases Checkbox y CheckboxGroup</h3>

<p>Un <tt>Checkbox</tt> es un componente que tiene dos estados: marcado (checked) y
desmarcado (unchecked). El usuario puede cambiar el estado del&nbsp; checkbox realizando
un clic sobre él. El estado del checkbox se representa por un valor <tt>boolean</tt> que
indica si está marcado (True) o desmarcado (False). La etiqueta del checkbox se indica
cuando se llama al constructor:</p>
<div align="center"><center>

<pre>Checkbox verTiempo = new Checkbox(&quot;Ver hora actual&quot;);  </pre>
</center></div>

<p align="left">La etiqueta de un checkbox puede modificarse utilizando el método <tt>setLabel(String)</tt>.
También podemos modificar el estado con el método <tt>setState(Boolean)</tt>. Por
ejemplo, si quiere que el checkbox <tt>verTiempo</tt> aparezca como marcado, deberemos
decir <tt>&quot;verTiempo.setState(true)&quot;</tt>, y para desmarcarlo <tt>&quot;verTiempo.setState(false)</tt>;&quot;
&nbsp; Puede averiguar el estado actual del checkbox llamando al método <tt>getState()</tt>
que le devolverá un valor boleano. Si cambia el estado debido a que el usuario hace clic
sobre el checkbox, se genera un evento. Su programa puede detectar y reaccionar ante el
evento. Sin embargo, a menudo es mas sencillo ignorar estos eventos y comprobar el estado
de la caja cuando sea necesario, empleando el método <tt>getState().</tt></p>

<p align="left">Los botones radio (radio buttons) están muy relacionados con los
checkbox. Los botones Radio, aparecen en grupo. Unicamente un botón del grupo puede estar
activo en un momento determinado. En Java un botón Radio es un objeto del tipo <tt>Checkbox</tt>
que es parte de un grupo. El grupo entero de los botones se representa por un objeto
perteneciente a la clase <tt>CheckboxGroup</tt>. La clase <tt>CheckBoxGroup</tt>tiene los
siguientes métodos</p>

<blockquote>
  <blockquote>
    <blockquote>
      <div align="left"><pre>public void setCurrent(Checkbox caja);
public Checkbox getCurrent();</pre>
      </div>
    </blockquote>
  </blockquote>
</blockquote>

<p align="left">para seleccionar uno de los botones del grupo, y determinar que botón
esta seleccionado en un momento determinado. (El método <tt>getCurrent()</tt> devuelve <tt>null</tt>
si ninguna de las cajas del grupo están seleccionadas en aquel momento).</p>

<p align="left">Para crear un grupo de RadioButtons, debe crear primero un objeto del tipo
<tt>CheckboxGroup</tt>. Para crear los botones individuales, utilice el constructor</p>
<div align="center"><center>

<pre>Checkbox(String etiqueta,CheckboxGroup nombre-grupo,boolean estado);  </pre>
</center></div>

<p align="left">El tercer parámetro de este constructor especifica el estado inicial
&nbsp; del checkbox. Recuerde que solo uno de los checkbox del grupo puede estar activado
(True). Por ejemplo:</p>

<blockquote>
  <blockquote>
    <blockquote>
      <div align="left"><pre>CheckboxGroup grupoColor = new CheckboxGroup();
Checkbox rojo = new Checkbox (&quot;Rojo&quot;, grupoColor, False);
Checkbox azul = new Checkbox (&quot;Azul&quot;, grupoColor, False);
Checkbox verde = new Checkbox (&quot;Verde&quot;, grupoColor, True);
Checkbox negro = new Checkbox (&quot;Negro&quot;, grupoColor, False);</pre>
      </div>
    </blockquote>
  </blockquote>
</blockquote>

<p align="left">Estas instrucciones crean cuatro Radiobuttons llamados &quot;Rojo&quot;,
&quot;Azul&quot;, &quot;Verde&quot;, y &quot;Negro&quot;. Inicialmente se deja
seleccionado el tercer botón, A pesar de eso, puede seguir añadiendo&nbsp; botones al
contenedor de forma individualizada. El <tt>CheckboxGroup</tt> en si mismo no es un
componente y no puede ser añadido al contenedor. Para emplear estos botones de forma
efectiva en su programa, probablemente deseara almacenar cualquier objeto <tt>Checkbox</tt>
o <tt>CheckboxGroup</tt>&nbsp; en una variable instanciable.</p>

<hr width="50%">

<h3>La clase Choice (Selección)</h3>

<p>Un <tt>CheckBoxGroup</tt> es una de las maneras de permitir al usuario el seleccionar
una opción de entre una lista predeterminada de opciones. La clase <tt>Choice</tt>
representa otra forma de hacer lo mismo. Un objeto de este tipo presenta las opciones en
formato de menú emergente. El menú presenta una lista de elementos. Normalmente, solo
esta visible el elemento seleccionado, sin embargo, cuando el usuario hace clic en el
menú, se presenta la lista entera y el usuario puede seleccionar uno de los ítems desde
la lista.</p>

<p>Cuando se construye el objeto <tt>Choice</tt>, inicialmente no tiene elementos; estos
se deberán añadir utilizando el método <tt>addItem(String)</tt>. El método <tt>countItems()</tt>
devuelve un <tt>int</tt> que define el numero de elementos que hay en la lista, y el
método</p>
<div align="center"><center>

<pre>public String getItem(int index)  </pre>
</center></div>

<p align="left">toma el elemento que se encuentra en la posición <tt>index</tt> de la
lista. (los elementos se numeran empezando en cero, no en uno). Otros métodos útiles
son:</p>

<blockquote>
  <blockquote>
    <blockquote>
      <div align="left"><pre>public int getSelectedIndex(); //numero  elemento seleccionado
public String getSelectedItem(); // texto elemento seleccionado
Public void select (int index); // seleccionar index
public void select (String itenName); // seleccionar itenName</pre>
      </div>
    </blockquote>
  </blockquote>
</blockquote>

<p align="left">El propósito de estos métodos parece obvio (observe que podemos
referirnos a cualquier elemento por la posición que ocupa o por el texto que contiene).</p>

<p align="left">Por ejemplo, el código siguiente crea un objeto del tipo <tt>Choice</tt>
que contiene las opciones Rojo, Azul, Verde y Negro:</p>

<blockquote>
  <blockquote>
    <blockquote>
      <div align="left"><pre>Choice colorElegido = new Choice();
colorElegido.addItem(&quot;Rojo&quot;);
colorElegido.addItem(&quot;Azul&quot;);
colorElegido.addItem(&quot;Verde&quot;);
colorElegido.addItem(&quot;Negro&quot;);</pre>
      </div>
    </blockquote>
  </blockquote>
</blockquote>

<p align="left">&nbsp;</p>

<hr width="50%">

<h3>La clase List</h3>

<p>Un objeto de tipo <tt>List</tt> es muy similar a un elemento <tt>Choice</tt>. Sin
embargo, <tt>List</tt> se presenta en pantalla como una lista de elementos desplazables.
Además, es posible crear listas en donde los usuarios puedan elegir mas de un elemento al
mismo tiempo. El constructor para un objeto <tt>List</tt> tiene la siguiente forma:</p>
<div align="center"><center>

<pre>List(int elementosVisibles,boolean multipleSeleccionPermitida);  </pre>
</center></div>

<p align="left">El primer parámetro indica cuantos elementos de la lista son visibles a
la vez; si la lista contiene mas elementos que los indicados, el usuario podrá utilizar
las barras de desplazamiento para moverse a lo largo de la lista. El segundo parámetro
determina si el usuario puede o no seleccionar mas de un elemento a la vez.</p>

<p align="left">La clase <tt>List</tt> incluye el método <tt>addItem(String)</tt> para
añadir elementos al final de la lista. También se pueden añadir elementos en una
posición determinada usando el método <tt>addItem(String,int)</tt>.(los elementos están
numerados empezando en cero). El método <tt>countItems()</tt> devuelve un <tt>int</tt>
que indica el numero de elementos que hay en la lista. El método <tt>delItem(int)</tt>
borra el elemento que se encuentra en la posición indicada. Y el método <tt>select(int)</tt>
se puede emplear para dejar seleccionado el elemento de la posición indicada en la lista.</p>

<p align="left">Si únicamente esta seleccionado un elemento de la lista, el método <tt>getSelectedIndex()</tt>
devuelve el índice del elemento y <tt>getSelectedItem()</tt> devuelve el elemento. Sin
embargo, si no hay elementos seleccionados o hay mas de uno, <tt>getSelectedIndex()</tt>
devuelve -1, y <tt>getSelectedItem()</tt> devuelve <tt>null</tt>. En este caso, deberá
emplear los métodos <tt>getSelectedItems() y getSelectedIndexes()</tt> para determinar
cuantos elementos se han seleccionados. (Sin embargo, estos métodos devuelven series
(arrays), que no estudiaremos hasta el <a href="Indice7.htm" tppabs="http://members.nbci.com/elcurso/Capitulo7/Indice7.htm">Capítulo 7</a>)</p>

<hr width="50%">

<h3>Las clases TextField y TextArea</h3>

<p><tt>TextField y TextAreas</tt> son cajas donde el usuario puede escribir y editar
texto. La diferencia entre ellas es que <tt>TextField</tt> contiene una única línea de
texto editable, mientras que <tt>TextArea</tt> presenta múltiples líneas e incluye
barras de scroll para que el usuario pueda desplazarse por todo el contenido de área.
(También es posible hacer que tanto <tt>TextField</tt> como <tt>TextArea</tt> sean
accesibles únicamente como lectura, de tal forma que el usuario las pueda leer pero no
modificar.)</p>

<p>Tanto<tt> TextField</tt> como <tt>TextArea </tt>son subclases de <tt>TextComponent</tt>,
que a su vez es subclase de <tt>Component</tt>. La clase <tt>TextComponent</tt> soporta la
idea de la selección. La selección es un subconjunto de caracteres incluyendo todos los
caracteres desde la posición de inicio hasta la de fin. La selección, aparece iluminada
en pantalla. El usuario selecciona texto arrastrando el ratón sobre el mismo. Alguno de
los métodos mas útiles incluidos en la clase <tt>TextComponent</tt> y que pueden ser
empleados tanto en <tt>TextField</tt> como en <tt>TextArea</tt> son:</p>

<blockquote>
  <pre>Public void setText(String newText); //cambia el texto
Public String getText(); // devuelve una copia del texto
Public String getSelectedText(); // devuelve el texto seleccionado
Public select(int inicio,int fin); //cambia el área de selección
	//quedando seleccionados los incluidos en el rango
	// empezando a contar desde cero
Public int getSelectionStart(); // toma el punto inicial seleccionado
Public int getSelectionEnd(); //Toma el final de la selección
Public void setEditable(boolean PuedeEditarse);
	//Determina de el texto puede ser o no editado 
	// por el usuario</pre>
</blockquote>

<p>La clase <tt>TextField</tt> no aporta ningún método útil mas a este conjunto. El
constructor para <tt>TextField</tt> toma la forma </p>
<div align="center"><center>

<pre>TextField(int columnas);  </pre>
</center></div>

<p align="left">donde columnas, especifica el numero de caracteres que deben ser visibles
en el campo de texto. Esto se utiliza para determinar la anchura del campo de texto. (Dado
que los caracteres pueden ser de distinto tamaño, el numero de caracteres visibles en un
campo de texto, puede no coincidir exactamente con el numero de columnas.). La indicación
del numero de columnas, no es obligatoria, si no se indica, el campo de texto se
expandirá a toda el área disponible. En este caso, puede emplear el constructor <tt>TextField()</tt>,
sin parámetros. También puede utilizar los siguientes constructores para indicar el
contenido inicial:</p>

<blockquote>
  <blockquote>
    <blockquote>
      <div align="left"><pre>TextField(String contenido);
TextField(String contenido, int columnas);</pre>
      </div>
    </blockquote>
  </blockquote>
</blockquote>

<p align="left">Los constructores para TextArea son:</p>

<blockquote>
  <blockquote>
    <blockquote>
      <div align="left"><pre>TextArea();
TextArea(int líneas, int columnas);
TextArea(String contenido);
TextArea(String contenido, int líneas, int columnas);</pre>
      </div>
    </blockquote>
  </blockquote>
</blockquote>

<p align="left"><br>
El parámetro líneas, especifica cuantas líneas&nbsp; serán visibles en el área de
texto. Esto, determinara la altura del área. Es común el utilizar el área de texto como
componente central de <tt>BorderLayout</tt>. En este caso, es mejor no especificar el
numero de líneas ni de columnas, permitiendo así&nbsp; que el área se expanda para
llenar todo el espacio central del contenedor.</p>

<p align="left">La clase <tt>TextArea</tt> añade algunos procedimientos bastante útiles
a los ya heredados de <tt>TextComponent</tt>.</p>

<blockquote>
  <blockquote>
    <blockquote>
      <div align="left"><pre>public void appendText(String text);
	// añade el texto indicado al final del contenido actual
public void insertText(String text, int pos);
	//inserta texto empezando en la posición indicada
public void replaceText(String text, int inicio, int fin);
	//borra el área de texto especificado por inicio/fin
	// y en su lugar inserta el nuevo texto</pre>
      </div>
    </blockquote>
  </blockquote>
</blockquote>

<p align="left">&nbsp;</p>

<hr width="50%">

<h3>La clase ScrollBar</h3>

<p align="center">Finalmente hemos llegado a la clase <tt>ScrollBar</tt>. Esencialmente, <tt>ScrollBar</tt>
permite al usuario el seleccionar un valor entero de entre un rango de valores. Las barras
pueden ser horizontales o verticales y tienen los siguientes componentes<img alt="Dibujo de una barra de movimiento" src="fig4-2.gif" tppabs="http://members.nbci.com/elcurso/Capitulo6/fig4.gif" WIDTH="203" HEIGHT="190"></p>

<p align="left">La posición del &quot;tab&quot; especifica el valor seleccionado en cada
momento. El usuario puede mover el tab arrastrándolo con el ratón, o pulsando sobre
alguna de las otras partes de la barra. En algunas plataformas, el tamaño de la barra
indica que porción de la región de scroll es visible en cada momento.</p>

<p align="left">Una barra de scroll tiene cuatro valores enteros asociados:</p>

<ul>
  <li><p align="left"><tt>min</tt>, que especifica el punto de partida del rango de posibles
    valores</p>
  </li>
  <li><p align="left"><tt>max</tt>, que especifica el punto de final del rango de posibles
    valores</p>
  </li>
  <li><p align="left"><tt>value</tt>, que define el valor seleccionado en cada momento, en
    alguna parte dentro del rango definido por mínimo y máximo</p>
  </li>
  <li><p align="left"><tt>visible</tt>, que especifica el tamaño del tab</p>
  </li>
</ul>

<p align="left">Estos valores se deben indicar cuando se crea la barra. El constructor
toma la forma</p>
<div align="center"><center>

<pre>ScrollBar(int orientación,int value,int visible, int min, int max);  </pre>
</center></div>

<p align="left">La <tt>orientación</tt> que especifica si la barra es horizontal o
vertical, puede tener uno de los siguientes valores, definidos por constantes&nbsp; <tt>Scrollbar</tt>.HORIZONTAL.
o <tt>Scrollbar.VERTICAL. </tt>Puede establecer el<tt> value </tt>de la barra en cualquier
momento con el método <tt>setValue(int).</tt>Si quiere establecer cualquier otro valor,
lo puede hacer utilizando el método:</p>
<div align="center"><center>

<pre><tt>public void setValues(int value, int visible, int min, int max);</tt>  </pre>
</center></div>

<p align="left">Los métodos <tt>getValue(), getVisible(), getMinimum(), y getMaximun()</tt>,
permiten leer el valor de cada uno de los parámetros.</p>

<p align="left">La siguiente pregunta es, cuanto se ha de mover el tab en la región de
scroll cuando el usuario pulsa las flechas arriba/abajo&nbsp; o página adelante/atrás?.
La cantidad que <tt>value</tt> cambia cuando el usuario pulsa flecha arriba/abajo, se
denomina <font color="#808000">incremento</font>. La cantidad que cambia cuando el usuario
pulsa pagina adelanta/atrás, se llama <font color="#808000">incremento de pagina</font>.
Por defecto, ambos valores valen 1. Pueden establecerse utilizando los siguientes
métodos:</p>

<blockquote>
  <blockquote>
    <blockquote>
      <div align="left"><pre>public void setLineIncrement(int incrementoLinea);
public void setPageIncrement(int incrementoPagina);</pre>
      </div>
    </blockquote>
  </blockquote>
</blockquote>

<p align="left">Veamos un ejemplo. Supongamos que quiere utilizar un área de dibujo muy
grande. que es demasiado grande para caber en la pantalla. Puede decidir presentar solo
una parte del área y proporcionar barras de scroll para permitir al usuario que se
desplace por toda el área. Vamos a decir que el tamaño real del área es de 1000 por
1000 pixeles, y la región que puede presentar es de 200 por 200. Vamos a ver como podría
establecer la barra vertical, la horizontal, seria básicamente lo mismo.</p>

<p align="left">El <tt>visible</tt> de la barra de scroll deberá ser 200, dado que es la
cantidad de pixeles que quiere presentar. El <tt>value</tt> de scroll representa la
coordenada vertical del pixel que esta situado en la parte superior del display. (Cuando
el valor cambie, deberá redibujar el área de display). El valor <tt>mínimo</tt> será
0, y el <tt>máximo</tt> será 800 ( El máximo no puede ser 1000 porque cuando el scroll
llegue al máximo, la coordenada de la base debe ser 1000, luego la coordenada de la parte
superior deberá ser 1000-200 = 800)</p>

<p align="left">El incremento de pagina para el scroll deberá ser algún valor
ligeramente inferior a 200, pongamos 190.Así, cuando el usuario utilice al
avance/retroceso pagina, el área de display avanzara un valor casi igual a su tamaño. El
incremento de línea podría ser 1, y seria correcto, pero puede que sea muy pequeño. Un
incremento de línea de 15, puede que tenga mas sentido, dado que el display avanzara 15
pixeles cuando el usuario pulse las flechas arriba/abajo. Como es natural, todos estos
valores deberán ser recalculados si el área de display cambia de tamaño.</p>

<hr width="50%">

<p>Ya esta. He explicado todas las subclases de <tt>Component</tt>, y he mencionado
bastantes de los métodos mas útiles de esas clases.&nbsp; Toma su tiempo el usar esos
componentes para conseguir algo valido. Como siempre, deberá practicar, experimentar, y
buscar así mismo la información que necesite.</p>

<hr>

<table border="0" width="100%" height="62" style="border-top: medium ridge">
  <tr>
    <td width="33%" height="58"><a href="seccion6_1.htm" tppabs="http://members.nbci.com/elcurso/Capitulo6/seccion6_1.htm"><img src="atras.gif" tppabs="http://members.nbci.com/elcurso/images/atras.gif" alt="Anterior" border="0" align="right" style="margin-top: 0px; margin-bottom: 0px" WIDTH="62" HEIGHT="62"></a></td>
    <td width="33%" height="58"><p align="center">&nbsp;&nbsp;&nbsp;&nbsp; <a href="indice6.htm" tppabs="http://members.nbci.com/elcurso/Capitulo6/indice6.htm"><img src="bicap.jpg" tppabs="http://members.nbci.com/elcurso/images/bicap.jpg" width="67" height="69" alt="Indice del Capitulo" border="0"></a><a href="indice.htm" tppabs="http://members.nbci.com/elcurso/indice.htm"><img src="bigen.jpg" tppabs="http://members.nbci.com/elcurso/images/bigen.jpg" width="66" height="68" alt="Indice General" border="0"></a></td>
    <td width="34%" height="58"><a href="seccion6_3.htm" tppabs="http://members.nbci.com/elcurso/Capitulo6/seccion6_3.htm"><img src="siguiente.gif" tppabs="http://members.nbci.com/elcurso/images/siguiente.gif" alt="Siguiente" align="left" border="0" WIDTH="57" HEIGHT="57"></a></td>
  </tr>
</table>
&nbsp;<!--msnavigation--></td></tr><!--msnavigation--></table><!--msnavigation--><table border="0" cellpadding="0" cellspacing="0" width="100%"><tr><td>

</td></tr><!--msnavigation--></table></body>
</html>
